// Code generated by generate-zip.pl; DO NOT EDIT.

package slices

import (
	"github.com/shogo82148/go-container/tuples"
)

// Zip2 returns a slice of 2-tuples.
// The returned slice have the length of the shortest slice.
func Zip2[T1, T2 any](s1 []T1, s2 []T2) []tuples.Tuple2[T1, T2] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	ret := make([]tuples.Tuple2[T1, T2], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple2[T1, T2]{s1[i], s2[i]}
	}
	return ret
}

// Zip3 returns a slice of 3-tuples.
// The returned slice have the length of the shortest slice.
func Zip3[T1, T2, T3 any](s1 []T1, s2 []T2, s3 []T3) []tuples.Tuple3[T1, T2, T3] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	ret := make([]tuples.Tuple3[T1, T2, T3], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple3[T1, T2, T3]{s1[i], s2[i], s3[i]}
	}
	return ret
}

// Zip4 returns a slice of 4-tuples.
// The returned slice have the length of the shortest slice.
func Zip4[T1, T2, T3, T4 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4) []tuples.Tuple4[T1, T2, T3, T4] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	ret := make([]tuples.Tuple4[T1, T2, T3, T4], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple4[T1, T2, T3, T4]{s1[i], s2[i], s3[i], s4[i]}
	}
	return ret
}

// Zip5 returns a slice of 5-tuples.
// The returned slice have the length of the shortest slice.
func Zip5[T1, T2, T3, T4, T5 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5) []tuples.Tuple5[T1, T2, T3, T4, T5] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	ret := make([]tuples.Tuple5[T1, T2, T3, T4, T5], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple5[T1, T2, T3, T4, T5]{s1[i], s2[i], s3[i], s4[i], s5[i]}
	}
	return ret
}

// Zip6 returns a slice of 6-tuples.
// The returned slice have the length of the shortest slice.
func Zip6[T1, T2, T3, T4, T5, T6 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6) []tuples.Tuple6[T1, T2, T3, T4, T5, T6] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	ret := make([]tuples.Tuple6[T1, T2, T3, T4, T5, T6], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple6[T1, T2, T3, T4, T5, T6]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i]}
	}
	return ret
}

// Zip7 returns a slice of 7-tuples.
// The returned slice have the length of the shortest slice.
func Zip7[T1, T2, T3, T4, T5, T6, T7 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7) []tuples.Tuple7[T1, T2, T3, T4, T5, T6, T7] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	ret := make([]tuples.Tuple7[T1, T2, T3, T4, T5, T6, T7], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple7[T1, T2, T3, T4, T5, T6, T7]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i]}
	}
	return ret
}

// Zip8 returns a slice of 8-tuples.
// The returned slice have the length of the shortest slice.
func Zip8[T1, T2, T3, T4, T5, T6, T7, T8 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8) []tuples.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	ret := make([]tuples.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple8[T1, T2, T3, T4, T5, T6, T7, T8]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i]}
	}
	return ret
}

// Zip9 returns a slice of 9-tuples.
// The returned slice have the length of the shortest slice.
func Zip9[T1, T2, T3, T4, T5, T6, T7, T8, T9 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9) []tuples.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	ret := make([]tuples.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple9[T1, T2, T3, T4, T5, T6, T7, T8, T9]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i]}
	}
	return ret
}

// Zip10 returns a slice of 10-tuples.
// The returned slice have the length of the shortest slice.
func Zip10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10 any](s1 []T1, s2 []T2, s3 []T3, s4 []T4, s5 []T5, s6 []T6, s7 []T7, s8 []T8, s9 []T9, s10 []T10) []tuples.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10] {
	l := len(s1)
	if len(s2) < l {
		l = len(s2)
	}
	if len(s3) < l {
		l = len(s3)
	}
	if len(s4) < l {
		l = len(s4)
	}
	if len(s5) < l {
		l = len(s5)
	}
	if len(s6) < l {
		l = len(s6)
	}
	if len(s7) < l {
		l = len(s7)
	}
	if len(s8) < l {
		l = len(s8)
	}
	if len(s9) < l {
		l = len(s9)
	}
	if len(s10) < l {
		l = len(s10)
	}
	ret := make([]tuples.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10], l)
	for i := 0; i < l; i++ {
		ret[i] = tuples.Tuple10[T1, T2, T3, T4, T5, T6, T7, T8, T9, T10]{s1[i], s2[i], s3[i], s4[i], s5[i], s6[i], s7[i], s8[i], s9[i], s10[i]}
	}
	return ret
}
